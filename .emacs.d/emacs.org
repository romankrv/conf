#+TITLE: Emacs Configuration Main File
#+AUTHOR: Roman Kalinichenko
#+EMAIL: romankrv@gmail.com

* Introduction
This is my =.emacs= file ... well, the top-level of it anyway.
I've written it in a [[http://www.orgmode.org][literate style], to make it easy to explain.

** About this file

If you're viewing the Org file, you can open source code blocks (those
are the ones in begin_src) in a separate buffer by moving your point
inside them and typing C-c ' (=org-edit-special=). This opens another
buffer in =emacs-lisp-mode=, so you can use =M-x eval-buffer= to load
the changes. If you want to explore how functions work, use =M-x
edebug-defun= to set up debugging for that function, and then call it.
You can learn more about edebug in the [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Edebug.html][Emacs Lisp]] manual.

I like using =(setq ...)= more than Customize because I can neatly
organize my configuration that way. Ditto for =use-package= - I mostly
use it to group together package-related config without lots of
=with-eval-after-load= calls, and it also makes declaring keybindings
easier.

** Emacs Executable

   While I often use [[http://emacsformacosx.com/builds][Emacs for Mac]], lately, I've been building Emacs
   from source using [[http://brew.sh/][Homebrew]]. I start by adding the following dependency:

   #+BEGIN_SRC sh :tangle no
     brew cask install xquartz
   #+END_SRC

   *Note:* I've been running into an issue where I want Emacs to display
   ligatures as well as work with the visual regular expression
   package. To get the both to work, I find I need to build from
   source after applying [[https://github.com/minimal/emacs/commit/812dd5119645a09bc025a9dddedad9474d12ecb6][this patch]]. According to the Homebrew
   documentation (see [[https://github.com/Homebrew/brew/blob/master/share/doc/homebrew/Formula-Cookbook.md#patches][the Patches section]]), we first:

   #+BEGIN_SRC sh :tangle no
     brew edit emacs
   #+END_SRC

   And add the following section

   #+BEGIN_EXAMPLE
   patch do
     url "https://github.com/minimal/emacs/commit/812dd5119645a09bc025a9dddedad9474d12ecb6.diff"
   end
   #+END_EXAMPLE

   And then build from source especially for the Mac:

   #+BEGIN_SRC sh :tangle no
     brew install emacs --HEAD --use-git-head --with-cocoa --with-gnutls --srgb
                        --with-librsvg --with-ns --with-imagemagick
     brew linkapps emacs
   #+END_SRC

   Not only does this install the latest version of Emacs in
   =/usr/local/bin/emacs=, but it also links a GUI version in
   =/Application/Emacs.app=.

   All Homebrew options for Emacs can be seen with the command:

   #+BEGIN_SRC sh :tangle no
     brew options emacs
   #+END_SRC
* General Settings
** My Directory Location

   Normally, the =user-emacs-directory= stores everything in a
   =.emacs.d= directory in the home directory, however, Aquamacs
   overrides that, and since I now feel the need to use these settings
   for both editors (sure feels like XEmacs all over again).

   Anyway, I have a new global variable for that:

   *This section put here as nominally and this code moved to init.el*
   #+BEGIN_SRC elisp
     (defconst RK/emacs-directory (concat (getenv "HOME") "/.emacs.d/"))
     (defun RK/emacs-subdirectory (d) (expand-file-name d RK/emacs-directory))
   #+END_SRC

** Directory Structure

   In case this is the first time running this on a computer, we need
   to make sure the following directories have been created.

   *This section put here as nominally and this code moved to init.el*
   #+BEGIN_SRC elisp
    (let* ((subdirs '("elisp" "backups"))
            (fulldirs (mapcar (lambda (d) (RK/emacs-subdirectory d)) subdirs)))
       (dolist (dir fulldirs)
         (when (not (file-exists-p dir))
           (message "Make directory: %s" dir)
           (make-directory dir))))
   #+END_SRC

** Customization Section

   While I would rather program my configurations, sometimes the Emacs
   menu system is "good enough", but I want it in its own file:

   #+BEGIN_SRC elisp
     (setq custom-file (expand-file-name "backups/custom.el" RK/emacs-directory))
     (when (file-exists-p custom-file)
       (load custom-file))
   #+END_SRC

** Setting up the Load Path

   Extra packages not available via the package manager go in my
   personal stash at: =$HOME/.emacs.d/elisp=
   #+BEGIN_SRC elisp
     (add-to-list 'load-path (RK/emacs-subdirectory "elisp"))
   #+END_SRC

** Modernizing Emacs

   With a long history of working on small machines without gigabytes
   of RAM, we might as well let Emacs be the beast it has always
   dreamed.

   First, let’s increase the cache before starting garbage collection:
   #+BEGIN_SRC elisp
     (setq gc-cons-threshold 50000000)
   #+END_SRC

   Found [[https://github.com/wasamasa/dotemacs/blob/master/init.org#init][here]] how to remove the warnings from the GnuTLS library when
   using HTTPS... increase the minimum prime bits size:
   #+BEGIN_SRC elisp
     (setq gnutls-min-prime-bits 4096)
   #+END_SRC
* Package Initialization
** Package Manager

   Emacs has become like every other operating system, and now has a package manager with its own collection
   repository, but since it is so conservative, we need to add more repositories to get all the sweet goodness, I demand.

   This section put here as nominally and this code moved to init.el
   #+BEGIN_SRC elisp :tangle no
     (require 'package)
     (setq package-enable-at-startup nil)
     (setq package-archives '(("org"       . "http://orgmode.org/elpa/")
                              ("gnu"       . "http://elpa.gnu.org/packages/")
                              ("melpa"     . "http://melpa.org/packages/")
                              ("marmalade" . "http://marmalade-repo.org/packages/")))
     (package-initialize)
     (package-refresh-contents)
   #+END_SRC

** Use-Package

   Using [[https://github.com/jwiegley/use-package][use-package]] to automatically install certain packages, as
   well as the ease of lazily loading them.

   This section put here as nominally and this code moved to init.el

   #+BEGIN_SRC elisp :tangle no
     (unless (package-installed-p 'use-package)
       (package-refresh-contents)
       (package-install 'use-package))
     (setq use-package-verbose t)

     (require 'use-package)
     (use-package auto-compile
       :config (auto-compile-on-load-mode))
   #+END_SRC

** Init File Support

   Load up my collection of enhancements to Emacs Lisp, including [[https://github.com/magnars/dash.el][dash]]
   and [[https://github.com/magnars/s.el][s]] for string manipulation, and [[https://github.com/rejeep/f.el][f]] for file manipulation.

   'Diminish' is a package that implements hiding or abbreviation
    of the mode line displays (lighters) of minor-modes.

   #+BEGIN_SRC elisp
     (require 'cl)

     (use-package dash
       :ensure t
       :config (eval-after-load "dash" '(dash-enable-font-lock)))

     (use-package s :ensure t)
     (use-package f :ensure t)
     (use-package diminish :ensure t)
    #+END_SRC

* Variables
** Personal information

#+BEGIN_SRC elisp
(setq user-full-name "Roman Kalinichenko"
      user-mail-address "romankrv@gmail.com")
#+END_SRC

** Tabs vs Spaces

   I have learned to distrust tabs in my source code, so let's make
   sure that we only have spaces. See [[http://ergoemacs.org/emacs/emacs_tabs_space_indentation_setup.html][this discussion]] for details.

   #+BEGIN_SRC elisp
     (setq-default indent-tabs-mode nil)
     (setq tab-width 2)
   #+END_SRC

   Make tab key do indent first then completion.

   #+BEGIN_SRC elisp
     (setq-default tab-always-indent 'complete)
   #+END_SRC

** Encrypting Files

   Synchronize notes formatted in org-mode across multiple computers
   with cloud storage services, like Dropbox? Those files are /cached/
   in various other storage facilities... so, I use symmetric key
   encryption with [[http://en.wikipedia.org/wiki/Pretty_Good_Privacy][PGP]].

   To get started on the Mac, install the goodies:

   #+BEGIN_SRC sh :tangle no
     brew install gpg
   #+END_SRC

   Now, any file loaded with a =gpg= extension, e.g. =some.org.gpg=,
   will prompt for a password (and then use =org-mode=).  Since these
   files are for my eyes only, I don’t need the key-ring prompt:

   #+BEGIN_SRC elisp
     (setq epa-file-select-keys 2)
   #+END_SRC

   If you trust your Emacs session on your computer, you can have
   Emacs cache the password.

   #+BEGIN_SRC elisp
     (setq epa-file-cache-passphrase-for-symmetric-encryption t)
   #+END_SRC

** Misc Variable Settings

   Lazy people like me never want to type “yes” when “y” will suffice.
   Does anyone type =yes= anymore?

   #+BEGIN_SRC elisp
     (fset 'yes-or-no-p 'y-or-n-p)
   #+END_SRC

   Fix the scrolling to keep point in the center:

   #+BEGIN_SRC elisp
     (setq scroll-conservatively 10000
           scroll-preserve-screen-position t)
   #+END_SRC

   I've been using Emacs for too long to need to re-enable each
   feature bit-by-bit:
   #+BEGIN_SRC elisp
     (setq disabled-command-function nil)
   #+END_SRC
* Navigation
** Smex

#+BEGIN_SRC elisp
(use-package smex
  :ensure t
  :init (setq smex-save-file "~/.emacs.d/backups/smex-items")
   (smex-initialize)
  :bind ("M-x" . smex)
        ("M-X" . smex-major-mode-commands))
#+END_SRC

** Goto Chg

  Goto last change in current buffer. Repeat to go to earlier changes. Negative arg
  to go back to more recent changes. With argument 0 (C-u 0) you get a description

  M-. can conflict with etags tag search. But C-. can get overwritten by
  flyspell-auto-correct-word. And goto-last-change needs a really fast key.

  #+BEGIN_SRC elisp
  (use-package goto-chg
    :ensure t
    :bind (([(control ?.)] . goto-last-change) ([(meta .)] . goto-last-change)))
  #+END_SRC

** Recent File List

   According to [[http://www.emacswiki.org/emacs-es/RecentFiles][this article]], Emacs already has the recent file

#+BEGIN_SRC elisp
(use-package recentf
  :init
  (setq recentf-save-file "~/.emacs.d/backups/recentf")
  (setq recentf-max-menu-items 200
        recentf-auto-cleanup 'never
        recentf-keep '(file-remote-p file-readable-p))
  (recentf-mode 1)
  (let ((last-ido "~/.emacs.d/backups/ido.last"))
    (when (file-exists-p last-ido)
      (delete-file last-ido)))
  :bind ("C-c f f" . recentf-open-files))
#+END_SRC

** Backup Settings

   This setting moves all backup files to a central location.
   Got it from [[http://whattheemacsd.com/init.el-02.html][this page]].

   Backup files are so very annoying, until the day they save
   your hide. That's when you don't want to look back and say
   "Man, I really shouldn't have disabled those stupid backups."
   These settings move all backup files to a central location.
   Bam! No longer annoying. As an added bonus, that last line
   makes sure your files are backed up even when the files are
   in version control. Do it.

   #+BEGIN_SRC elisp
     (setq backup-directory-alist
           `(("." . ,(expand-file-name
                      (RK/emacs-subdirectory "backups")))))
   #+END_SRC

   Tramp should do the same:
   #+BEGIN_SRC elisp
     (setq tramp-backup-directory-alist backup-directory-alist)
   #+END_SRC

   Make backups of files, even when they're in version control:
   #+BEGIN_SRC elisp
     (setq vc-make-backup-files t)
   #+END_SRC

   And let’s make sure our files are saved if we wander off and
   defocus the Emacs application:

   #+BEGIN_SRC elisp
     (defun save-all ()
       "Save all dirty buffers without asking for confirmation."
       (interactive)
       (save-some-buffers t))

     (add-hook 'focus-out-hook 'save-all)
   #+END_SRC

   Move 'auto-save-list' directory to the custom directory
   #+BEGIN_SRC
     (setq auto-save-list-file-prefix "~/.emacs.d/backups/auto-save-list/.saves-")
   #+END_SRC

** More window movement

   Offer a *visual* way to choose a window to switch to

#+BEGIN_SRC elisp
(use-package switch-window
  :ensure t
  :bind (("C-x o" . switch-window))
  :bind (("C-x 1" . switch-window-then-maximize))
  :bind (("C-x 2" . switch-window-then-split-below))
  :bind (("C-x 3" . switch-window-then-split-right))
  :bind (("C-x 4" . switch-window-then-split-delete)))
#+END_SRC

** Move to beginning of line
   Copied from http://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/

   Move point to the first non-whitespace character on this line. If point is
   already there, move to the beginning of the line. Effectively toggle between
   the first non-whitespace character and the beginning of the line. If ARG is
   not nil or 1, move forward ARG - 1 lines first. If point reaches the beginning
   or end of the buffer, stop there.

#+BEGIN_SRC elisp
(defun my/smarter-move-beginning-of-line (arg)
  (interactive "^p")
  (setq arg (or arg 1))
  ;; Move lines first
  (when (/= arg 1)
    (let ((line-move-visual nil))
      (forward-line (1- arg))))
  (let ((orig-point (point)))
    (back-to-indentation)
    (when (= orig-point (point))
      (move-beginning-of-line 1))))

;; remap C-a to `smarter-move-beginning-of-line'
(global-set-key [remap move-beginning-of-line]
                'my/smarter-move-beginning-of-line)
#+END_SRC

** Copy filename to clipboard

   http://emacsredux.com/blog/2013/03/27/copy-filename-to-the-clipboard/
   https://github.com/bbatsov/prelude

#+BEGIN_SRC elisp
(defun prelude-copy-file-name-to-clipboard ()
  "Copy the current buffer file name to the clipboard."
  (interactive)
  (let ((filename (if (equal major-mode 'dired-mode)
                      default-directory
                    (buffer-file-name))))
    (when filename
      (kill-new filename)
      (message "Copied buffer file name '%s' to the clipboard." filename))))
#+END_SRC

** IDO (Interactively DO Things)
   According to [[http://www.masteringemacs.org/articles/2010/10/10/introduction-to-ido-mode/][Mickey]], IDO is the greatest thing.

   +BEGIN_SRC
     (use-package ido
       :ensure t
       :init  (setq ido-enable-flex-matching t
                    ido-ignore-extensions t
                    ido-use-virtual-buffers t
                    ido-everywhere t)
       :config
       (ido-mode 1)
       (ido-everywhere 1)
       (add-to-list 'completion-ignored-extensions ".pyc"))
   +END_SRC
   Add to IDO, the [[https://github.com/lewang/flx][FLX]] package:

   +BEGIN_SRC
     (use-package flx-ido
        :ensure t
        :init (setq ido-enable-flex-matching t
                    ido-use-faces nil)
        :config (flx-ido-mode 1))
   +END_SRC

   According to [[https://gist.github.com/rkneufeld/5126926][Ryan Neufeld]], we could make IDO work vertically,
   which is much easier to read. For this, I use [[https://github.com/gempesaw/ido-vertical-mode.el][ido-vertically]]:

   +BEGIN_SRC
     (use-package ido-vertical-mode
       :ensure t
       :init               ; I like up and down arrow keys:
       (setq ido-vertical-define-keys 'C-n-C-p-up-and-down)
       :config
       (ido-vertical-mode 1))
       +END_SRC

** Desktop (saving emacs sessions)

   Use the desktop library to save the state of Emacs from one session to another.
   Once you save the Emacs desktop—the buffers, their file names, major modes,
   buffer positions, and so on—then subsequent Emacs sessions reload the saved desktop.

#+BEGIN_SRC elisp
   (desktop-save-mode 1)
   (setq desktop-path '("~/.emacs.d/backups"))
   (setq desktop-dirname "~/.emacs.d/backups")
   (setq desktop-base-file-name "emacs-desktop")

   ;; remove desktop after it's been read
   (add-hook 'desktop-after-read-hook
	     '(lambda ()
                ;; desktop-remove clears desktop-dirname
                (setq desktop-dirname-tmp desktop-dirname)
                (desktop-remove)
                (setq desktop-dirname desktop-dirname-tmp)))

   (defun saved-session ()
     (file-exists-p (concat desktop-dirname "/" desktop-base-file-name)))

   ;; use session-restore to restore the desktop manually
   (defun session-restore ()
     "Restore a saved emacs session."
     (interactive)
     (if (saved-session)
         (desktop-read)
       (message "No desktop found.")))

   ;; use session-save to save the desktop manually
   (defun session-save ()
     "Save an emacs session."
     (interactive)
     (if (saved-session)
         (if (y-or-n-p "Overwrite existing desktop? ")
             (desktop-save-in-desktop-dir)
           (message "Session not saved."))
       (desktop-save-in-desktop-dir)))

   ;; ask user whether to restore desktop at start-up
   ;(add-hook 'after-init-hook
   ;          '(lambda ()
   ;             (if (saved-session)
   ;                 (if (y-or-n-p "Restore desktop? ")
   ;                     (session-restore)))))
#+END_SRC

  Specifying Files Not to be Opened
  You can specify buffers which should not be saved, by name or by mode:

#+BEGIN_SRC elisp
   (setq desktop-buffers-not-to-save
        (concat "\\("
                "^nn\\.a[0-9]+\\|\\.log\\|(ftp)\\|^tags\\|^TAGS"
                "\\|\\.emacs.*\\|\\.diary\\|\\.newsrc-dribble\\|\\.bbdb"
	        "\\)$"))
   (add-to-list 'desktop-modes-not-to-save 'dired-mode)
   (add-to-list 'desktop-modes-not-to-save 'Info-mode)
   (add-to-list 'desktop-modes-not-to-save 'info-lookup-mode)
   (add-to-list 'desktop-modes-not-to-save 'fundamental-mode)
#+END_SRC

** Windmove (switching between windows)

   Windmove lets you move between windows with something more natural than
   cycling through =C-x o= (=other-window=). Windmove doesn't behave well
   with Org, so we need to use different keybindings.

#+BEGIN_SRC elisp
(use-package windmove
  :ensure
  :bind
  (("<f2> <right>" . windmove-right)
   ("<f2> <left>" . windmove-left)
   ("<f2> <up>" . windmove-up)
   ("<f2> <down>" . windmove-down)))
#+END_SRC

** Winner mode (undo/redo window configuration)

   Winner Mode is a global minor mode. When activated, it allows you to “undo”
   (and “redo”) changes in the window configuration with the key commands
   ‘C-c left’ and ‘C-c right’

#+BEGIN_SRC elisp
(when (fboundp 'winner-mode)
      (winner-mode 1))
#+END_SRC
** Anzu (display the typed matches in the mode-line)

   Anzu is an Emacs port of anzu.vim that provides a minor mode which displays
   current match and total matches information in the mode-line in various search modes.

 #+BEGIN_SRC elisp
 (use-package anzu
   :ensure t
   :diminish anzu-mode nil
   :config
    (progn
      (global-anzu-mode t)
      (global-set-key [remap query-replace-regexp] 'anzu-query-replace-regexp)
      (global-set-key [remap query-replace] 'anzu-query-replace)))
 #+END_SRC

* Display Settings

  I've been using Emacs for several years, and appreciate a certain
  minimalist approach to its display. While you can turn these off
  with the menu items now, it is just as easy to set them here.

  #+BEGIN_SRC elisp
    (setq initial-scratch-message "") ;Uh, I know what Scratch is for
    (setq visible-bell t)             ;Get rid of the beeps
    (global-hl-line-mode +1)          ;Highlight Current Line
    (scroll-bar-mode -1)              ;Scrollbars are waste screen estate

    (when (window-system)
      (tool-bar-mode 0)               ;; Toolbars were only cool with XEmacs
      (when (fboundp 'horizontal-scroll-bar-mode)
        (horizontal-scroll-bar-mode -1)))
  #+END_SRC

  #+BEGIN_SRC elisp
   ;(add-to-list 'default-frame-alist '(fullscreen . maximized))
  #+END_SRC

  Show white spaces at the end of lines
  Do not show the cursor in non-active window
  When on a TAB, the cursor has the TAB length
  #+BEGIN_SRC elisp
  (setq-default
   show-trailing-whitespace t
   cursor-in-non-selected-windows nil
   use-dialog-box nil
   x-stretch-cursor t)
  #+END_SRC

* Key Bindings
** Expand Region

   Wherever you are in a file, and whatever the type of file, you can
   slowly increase a region selection by logical segments by using
   Magnar's [[https://github.com/magnars/expand-region.el][expand-region]] project.

     #+BEGIN_SRC elisp
     (use-package expand-region
       :ensure t
       :config
       (defun ha/expand-region (lines)
         "Prefix-oriented wrapper around Magnar's `er/expand-region'.

     Call with LINES equal to 1 (given no prefix), it expands the
     region as normal.  When LINES given a positive number, selects
     the current line and number of lines specified.  When LINES is a
     negative number, selects the current line and the previous lines
     specified.  Select the current line if the LINES prefix is zero."
         (interactive "p")
         (cond ((= lines 1)   (er/expand-region 1))
               ((< lines 0)   (ha/expand-previous-line-as-region lines))
               (t             (ha/expand-next-line-as-region (1+ lines)))))

       (defun ha/expand-next-line-as-region (lines)
         (message "lines = %d" lines)
         (beginning-of-line)
         (set-mark (point))
         (end-of-line lines))

       (defun ha/expand-previous-line-as-region (lines)
         (end-of-line)
         (set-mark (point))
         (beginning-of-line (1+ lines)))

       :bind ("C-=" . ha/expand-region))
   #+END_SRC
** Displaying Command Sequences

   Many command sequences may be logical, but who can remember them all?
   Which-key is a minor mode for Emacs that displays the key bindings following
   your currently entered incomplete command (a prefix) in a popup. For example,
   after enabling the minor mode if you enter C-x and wait for the default of 1
   second the minibuffer will expand with all of the available key bindings that
   follow C-x

   #+BEGIN_SRC elisp
     (use-package which-key
       :ensure t
       :defer 10
       :diminish which-key-mode
       :config

       ;; Replacements for how KEY is replaced when which-key displays
       ;;   KEY → FUNCTION
       ;; Eg: After "C-c", display "right → winner-redo" as "▶ → winner-redo"
       (setq which-key-key-replacement-alist
             '(("<\\([[:alnum:]-]+\\)>" . "\\1")
               ("left"                  . "◀")
               ("right"                 . "▶")
               ("up"                    . "▲")
               ("down"                  . "▼")
               ("delete"                . "DEL") ; delete key
               ("\\`DEL\\'"             . "BS") ; backspace key
               ("next"                  . "PgDn")
               ("prior"                 . "PgUp"))

             ;; List of "special" keys for which a KEY is displayed as just
             ;; K but with "inverted video" face... not sure I like this.
             which-key-special-keys '("RET" "DEL" ; delete key
                                      "ESC" "BS" ; backspace key
                                      "SPC" "TAB")

             ;; Replacements for how part or whole of FUNCTION is replaced:
             which-key-description-replacement-alist
             '(("Prefix Command" . "prefix")
               ("\\`calc-"       . "") ; Hide "calc-" prefixes when listing M-x calc keys
               ("\\`projectile-" . "𝓟/")
               ("\\`org-babel-"  . "ob/"))

             ;; Underlines commands to emphasize some functions:
             which-key-highlighted-command-list
             '("\\(rectangle-\\)\\|\\(-rectangle\\)"
               "\\`org-"))

       ;; Change what string to display for a given *complete* key binding
       ;; Eg: After "C-x", display "8 → +unicode" instead of "8 → +prefix"
       (which-key-add-key-based-replacements
         "C-x 8"   "unicode"
         "C-c T"   "toggles-"
         "C-c p s" "projectile-search"
         "C-c p 4" "projectile-other-buffer-"
         "C-x a"   "abbrev/expand"
         "C-x r"   "rect/reg"
         "C-c /"   "engine-mode-map"
         "C-c C-v" "org-babel")

       (which-key-mode 1))
   #+END_SRC

* Clipboard

#+BEGIN_SRC elisp
(use-package clipmon
  :disabled t
  :init (progn
          (setq clipmon-action 'kill-new clipmon-timeout nil clipmon-sound nil
                clipmon-cursor-color nil clipmon-suffix nil) (clipmon-mode)))
#+END_SRC

* Tools
** Git
   I like [[https://github.com/syohex/emacs-git-gutter-fringe][git-gutter-fringe]]:
   #+BEGIN_SRC elisp
     (use-package git-gutter-fringe
        :ensure t
        :diminish git-gutter-mode
        :init (setq git-gutter-fr:side 'right-fringe)
        :config (global-git-gutter-mode t))
   #+END_SRC

   I want to have special mode for Git's =configuration= file:

   #+BEGIN_SRC elisp
     (use-package gitconfig-mode :ensure t)
     (use-package gitignore-mode :ensure t)
   #+END_SRC

   Finally, I want to play with [[https://github.com/pidu/git-timemachine][Git Time Machine]] project for stepping
   backward through the version history of a file:
   Visit a git-controlled file and issue M-x git-timemachine (or bind it to a
   keybinding of your choice). If you just need to toggle the time machine you can use
   *M-x git-timemachine-toggle.*

   _Use the following keys to navigate historic version of the file_:
   p Visit previous historic version
   n Visit next historic version
   w Copy the abbreviated hash of the current historic version
   W Copy the full hash of the current historic version
   g Goto nth revision
   q Exit the time machine.
   b Run magit-blame on the currently visited revision (if magit available).
   #+BEGIN_SRC elisp
     (use-package git-timemachine :ensure t)
   #+END_SRC

** Magit

  Git is [[http://emacswiki.org/emacs/Git][already part of Emacs]]. However, [[http://philjackson.github.com/magit/magit.html][Magit]] is sweet.
  Don't believe me? Check out [[https://www.youtube.com/watch?v=vQO7F2Q9DwA][this video]].
  #+BEGIN_SRC elisp
    (use-package magit
      :ensure t
      :commands magit-status magit-blame
      :init
      (defadvice magit-status (around magit-fullscreen activate)
        (window-configuration-to-register :magit-fullscreen)
        ad-do-it
        (delete-other-windows))
      :config
      (setq magit-branch-arguments nil
         ;; use ido to look for branches
         magit-completing-read-function 'magit-ido-completing-read
         ;; don't put "origin-" in front of new branch names by default
         magit-default-tracking-name-function 'magit-default-tracking-name-branch-only
         magit-push-always-verify nil
         ;; Get rid of the previous advice to go into fullscreen
         magit-restore-window-configuration t)
      :bind ("C-x g" . magit-status))
  #+END_SRC

  I like having Magit to run in a /full screen/ mode, and add the
  above =defadvice= idea from [[https://github.com/magnars/.emacs.d/blob/master/setup-magit.el][Sven Magnars]].
  *Note:* Use the [[https://github.com/jwiegley/emacs-release/blob/master/lisp/vc/smerge-mode.el][smerge-mode]] that is now part of Emacs.

** Google-translate

   Google-translate

   #+BEGIN_SRC elisp
   (use-package google-translate
     :ensure t
     :config
     (progn
       (setq google-translate-default-source-language "en")
       (setq google-translate-default-target-language "ru")
       (global-set-key "\C-ct" 'google-translate-at-point)
       (global-set-key "\C-cT" 'google-translate-query-translate)
       (global-set-key "\C-cl" 'google-translate-at-point-reverse)
       (global-set-key "\C-cL" 'google-translate-query-translate-reverse)
       (set-face-attribute 'google-translate-translation-face nil :height 1.0)))
   #+END_SRC

** HTTP REST client tool

   This is a tool to manually explore and test HTTP REST webservices.
   Runs queries from a plain-text query sheet, displays results as a
   pretty-printed XML, JSON and even images.

   restclient-mode is a major mode which does a bit of highlighting
   and supports a few additional keypresses:

   ;; C-c C-c: runs the query under the cursor, tries to pretty-print the response (if possible)
   ;; C-c C-r: same, but doesn't do anything with the response, just shows the buffer
   ;; C-c C-v: same as C-c C-c, but doesn't switch focus to other window
   ;; C-c C-p: jump to the previous query
   ;; C-c C-n: jump to the next query
   ;; C-c C-.: mark the query under the cursor
   ;; C-c C-u: copy query under the cursor as a curl command

   More examples can be found https://github.com/pashky/restclient.el/blob/master/examples/httpbin

   #+BEGIN_SRC elisp
   (use-package restclient
     :ensure t
     :defer t)
   #+END_SRC

* Org-mode

  Pre-Install for Org-mode:
  =$ gem install taskjuggler=

  #+BEGIN_SRC elisp
    (require 'init-org-mode)
  #+END_SRC

* Programming Language (Coding)
** Python

  #+BEGIN_SRC elisp
    (require 'init-python)
  #+END_SRC

* Miscellaneous Settings
** Transpose word

   Hacking Emacs to change the behavior of existing functions.
   Essentially, I show a little trick, but then show how to use
   defadvice to change the behavior of transpose-words.

   #+BEGIN_SRC elisp
   (defun my/transpose-words (arg)
     (interactive "p")
     (if (looking-at "$")
         (backward-word 1))
     (transpose-words arg))

   (defadvice transpose-words
     (before my/traspose-words)
     "Transpose last two words when at end of line."
     (if (looking-at "$")
       (backward-word 1)))

   (ad-activate 'transpose-words)
   (global-set-key (kbd "M-t") 'my/transpose-words)
#+END_SRC

** Line Numbers

   Turn =linum-mode= on/off with =Command-K= (see the [[*Macintosh][Macintosh]]
   section above).  However, I turn this on automatically for
   programming modes.

   #+BEGIN_SRC elisp
     (use-package linum
       :init
       (add-hook 'prog-mode-hook 'linum-mode)
       (add-hook 'linum-mode-hook (lambda () (set-face-attribute 'linum nil :height 110)))

       :config
       (defun linum-fringe-toggle ()
         "Toggles the line numbers as well as the fringe."    (interactive)
         (cond (linum-mode (fringe-mode '(0 . 0))
                           (linum-mode -1))
               (t          (fringe-mode '(8 . 0))
                           (linum-mode 1))))

       :bind (("A-C-k"   . linum-mode)
              ("s-C-k"   . linum-mode)
              ("A-C-M-k" . linum-fringe-toggle)
              ("s-C-M-k" . linum-fringe-toggle)))
   #+END_SRC

   *Note:* make the line numbers a fixed size, then increasing or
   decreasing the font size doesn't truncate the numbers.

   The [[https://github.com/coldnew/linum-relative][linum-relative]] mode allows one to see the /destination/ line as a
   relative distance (like one 9 lines lower), and then =C-9 C-n= can
   quickly pop to it.

   #+BEGIN_SRC elisp
     (use-package linum-relative
       :ensure t
       :config
       (defun linum-new-mode ()
         "If line numbers aren't displayed, then display them.
          Otherwise, toggle between absolute and relative numbers."
         (interactive)
         (if linum-mode
             (linum-relative-toggle)
           (linum-mode 1)))

       :bind ("A-k" . linum-new-mode)
             ("s-k" . linum-new-mode))   ;; For Linux
   #+END_SRC

** Save point position between sessions

The saveplace package is part of Emacs, and remembers the position
of point - even between emacs sessions.  The last line sets the path
to where saveplace stores your position data. Change it at your peril!

#+BEGIN_SRC elisp
;; Save point position between sessions
(setq save-place-file "~/.emacs.d/backups/saved-places")
(require 'saveplace)
(setq-default save-place t)

;; remember cursor position, for emacs 25.1 or later
(if (version< emacs-version "25.0")
    (progn
      (require 'saveplace)
      (setq-default save-place t))
  (save-place-mode 1))
#+END_SRC

** Save File Position

   Save the point position for every file, and restore it when that
   file is reloaded.

   #+BEGIN_SRC elisp
     (use-package saveplace
        :init
        (setq-default save-place t)
        (setq save-place-forget-unreadable-files t
              save-place-skip-check-regexp "\\`/\\(?:cdrom\\|floppy\\|mnt\\|/[0-9]\\|\\(?:[^@/:]*@\\)?[^@/:]*[^@/:.]:\\)"))
   #+END_SRC

** Strip Whitespace on Save

   When I save, I want to always, and I do mean always strip all
   trailing whitespace from the file.

   #+BEGIN_SRC elisp
     (add-hook 'before-save-hook 'delete-trailing-whitespace)
   #+END_SRC

* Technical Artifacts
** Run org-babel-tangle on saving that file

   Stroke C-x C-s on the modified file and you see message like this:
   =Tangled 1 code block from emacs.org=

   #+BEGIN_SRC elisp
   ;; Tangle Org-s files when we'll to save them.
   (defun tangle-on-save-org-mode-file()
     (when (string= (message "%s" major-mode) "org-mode")
     (org-babel-tangle)))
   (add-hook 'after-save-hook 'tangle-on-save-org-mode-file)
   #+END_SRC
** Configure the Graphical Settings

   If we are running in a windowed environment where we can set up
   fonts and whatnot, call the 'mac' stuff... which will still work
   for Linux too.

   #+BEGIN_SRC elisp
     (if (window-system)
        (require 'init-client)
      (require 'init-server))
   #+END_SRC

** Load up the Local Configuration

   Before we finish, we need to check if there is a local file for us to load and evaluate.
   We assume the local file has been tangled and provides the init-local key:
   #+BEGIN_SRC elisp
      (require 'init-local nil t)
   #+END_SRC

   *Make sure that we can simply require this library.*
   #+BEGIN_SRC elisp
     (provide 'init-main)
   #+END_SRC

   Note: Toggles the file make by hit: C-c C-v t

#+DESCRIPTION: A literate programming version of my Emacs Initialization script, loaded by the .emacs file.
#+PROPERTY:    header-args:elisp  :tangle ~/.emacs.d/elisp/init-main.el
#+PROPERTY:    header-args:shell  :tangle no
#+PROPERTY:    header-args        :results silent   :eval no-export   :comment org
#+OPTIONS:     num:nil toc:nil todo:nil tasks:nil tags:nil
#+OPTIONS:     skip:nil author:nil email:nil creator:nil timestamp:nil
#+INFOJS_OPT:  view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
